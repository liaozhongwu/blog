{"blogs":[{"_id":"5707ce034843cf0759639f2e","title":"雪颂","content":"雪花肆意飘洒\r\n大地银装素裹\r\n世界变得纯净而寂寞\r\n\r\n刺骨的冷风倚着枝头曼舞\r\n古老的音调如同神秘咒语\r\n\r\n在飘零的雪花间依洄\r\n在流浪的思潮里汹涌\r\n汹涌着淡淡的欣愉\r\n欣愉与你此刻的相逢\r\n\r\n你是优雅的精灵\r\n从不掩饰自己的美\r\n\r\n雄伟的山川是你华丽的舞姿\r\n潺潺的流水是你深情的密语\r\n笔下的文字是你迷人的微笑\r\n\r\n静谧的倩影\r\n迷人的暗香\r\n冗长的寒夜里格外动人\r\n\r\n你是冷艳的精灵\r\n自深邃的高空缓缓滑落\r\n奔向这片未知的土地\r\n\r\n冰冷足以冻结四海\r\n艳丽迫使百花蒙羞\r\n\r\n哪怕落地的瞬间便是融化\r\n也不辜负歌咏你的诗篇\r\n\r\n你是纯洁的精灵\r\n上天将纯洁的你洒向人间\r\n净化茫茫浮躁的尘世\r\n\r\n无边无际的洁白是你灵魂的色彩\r\n如月华般的光亮是你甜美的面庞\r\n精心雕刻的轮廓是你傲人的身形\r\n\r\n黯淡的大地不再凋零\r\n灰败的枫叶不再哭泣\r\n\r\n站在你柔软的手心里无声的呐喊\r\n向纯洁的冰雪女神倾诉不能诉说的心境\r\n\r\n世事变化\r\n沧海桑田\r\n唯有你不识人间烟火\r\n唯有你依然美丽记忆\r\n永恒的纯白\r\n不老的容颜\r\n\r\n感谢倾情陪伴\r\n直到生命终结","__v":0,"createTime":"2015-09-03 20:23:18"},{"_id":"5707ce034843cf0759639f2f","title":"Promise的理解","content":"## Overview\r\n\r\n在Promise产生之前，由于JS的异步特性，一般的异步操作是通过回调来处理的\r\n\r\n于是在复杂的代码逻辑就出现传说中的回调大坑\r\n\r\n    step1(function (value1) {\r\n        // do something with value1\r\n        step2(function (value2) {\r\n            // do something with value2\r\n            step3(function (value3) {\r\n                // do something with value3\r\n                step4(function (value4) {\r\n                    ...\r\n                })\r\n            })\r\n        });\r\n    });\r\n\r\nPromise则很好的解决了这个问题，用Promise可以写出这样优雅的代码\r\n    \r\n    step1() \r\n    .then(step2)\r\n    .then(step3)\r\n    .then(step4)\r\n    .catch(function (err) { \r\n        // handle error\r\n    })\r\n    .done()\r\n    \r\n异步操作的处理决定了Promise必须是有状态的，一般来说有等待、解决、拒绝三种状态\r\n\r\n等待态一般是等待请求数据，这时Promise会延迟直到数据返回\r\n\r\n解决态一般为Promise执行成功，此时把数值通过正常处理函数返回\r\n\r\n拒绝态一般为Promise发生错误，此时把错误通过异常处理函数抛出\r\n\r\n由此创建Promise对象一般需要一个决定解决或拒绝的函数\r\n\r\n该函数在对象创建时被执行以获得当前状态，接着Promise等待处理函数\r\n\r\n    var promise = new Promise(function (reslove, reject) {\r\n        // do something\r\n        if (...) {\r\n            resolve(value);\r\n        } else {\r\n            reject(error);  \r\n        }\r\n    });\r\n    \r\nPromise的then是Promise的处理函数，对应于Promise状态then必须有相应的处理函数onResolve和onReject\r\n\r\n规范约定了then第一个参数表示onResolve，第二个参数表示onReject，不处理某状态可为空或null\r\n\r\n    promise.then(function (value) {\r\n        // handle value\r\n    }, function (error) {\r\n        // handle error\r\n    });\r\n\r\nPromise会根据当前状态决定执行onResolve或者onReject，一般onResolve处理数据，onReject处理异常\r\n\r\n为了实现优雅的链式调用，then同样返回Promise对象\r\n\r\n并且当前then处理函数onResolve/onReject的返回值被保存在Promise对象中\r\n\r\n以便Promise提供给下一个then处理函数onResolve/onReject使用\r\n\r\n    promise.then(function (value1) {\r\n        // handle value1\r\n        return value2;\r\n    }).then(function (value2) {\r\n        // handle value2\r\n        return value3;\r\n    }).then(function (value3) {\r\n        // handle value3\r\n    });\r\n\r\n因为链式调用的关系，如果Promise为拒绝态，那么链式调用所有的onResolve都不会被调用，所以可以在最后捕获异常\r\n\r\n    promise.then(...).then(...).then(..., function (error) {\r\n        // handle error\r\n    });\r\n\r\n为了符合语义化，Promise使用catch专门处理错误，catch只接受onReject处理函数\r\n    \r\n    promise.then(...).then(...).catch(function (error) {\r\n        // handle error\r\n    });\r\n    \r\n基于返回值的链式调用也决定了Promise只能有一个值，如果想处理多个变量可以使用数组或对象\r\n\r\n当然Promise也提供了all方法解决这一问题\r\n\r\nPromise.all(iterable) 接受一个可迭代对象参数，一般为promise数组，返回一个promise对象，该对象会在参数中所有promise处理完之后才会处理，此时该promise处理的值应为之前所有返回值的数组\r\n\r\n    var p1 = Promise.resolve(1);\r\n    var p2 = Promise.resolve(2);\r\n    \r\n    Promise.all([p1, p2])\r\n    .then(function (value) {\r\n        // [1, 2]\r\n    });\r\n\r\n综上所述，Promise至少有的闭包变量为：state状态、Value/Error值、onResolve/OnReject处理函数","__v":0,"createTime":"2015-09-28 16:43:51"},{"_id":"5707ce034843cf0759639f30","title":"ESMAScript6笔记","content":"## 1. let\r\n在ECMAScript5中变量是没有块级作用域的，函数体中所有用到的，也即变量提升，ECMAScript新增的let允许声明块级作用于，使得变量只在块级内生效\r\n\r\n\tfor (var i = 0; i < array.length; i++) {\r\n\t\t(function (index) {\r\n\t\t\t// do something with index\r\n\t\t})(i);\r\n\t}\r\n\tfor (let i = 0; i< array.length; i++) {\r\n\t\t// do something with i\r\n\t}\r\n\r\n## 2. const\r\n熟悉C++的知道const表示变量不能被修改，但是对于对象其属性还是可以更改，书中建议使用Object.freeze(obj)和Object.deepFreeze(obj)来使得对象的属性不能被更改\r\n \r\n\tconst a = \"a\";\r\n\ta = \"b\"; // fail\r\n\tconst obj = Object.freeze({a: \"a\"});\r\n\tobj.a = \"b\"; // fail\r\n\tconst obj2 = Object.deepFreeze({a: {value: \"a\"}};\r\n\tobj2.a.value = \"b\"; // fail\r\n \r\n## 3. 解构赋值\r\nES6允许批量地从对象或者数组中提取值赋予一组变量\r\n\r\n\tvar [a, b] = [1, 2]; // var a = 1, b = 2\r\n\tvar {a, b} = {a: 1, b: 2}; // var a = 1, b = 2\r\n\r\n## 4. 字符串扩展\r\n\tboolean include(str); // 是否能找到字符串\r\n\tboolean startsWith(str); // 是否以字符串开始\r\n\tboolean endsWidth(str); // 是否以字符串结束\r\n\r\n## 5. 函数扩展\r\n\r\n\t// 可以设置默认值\r\n\tfunction (x = 1) {\r\n\t\tconsole.log(x); // 1\r\n\t}\r\n\t// 箭头函数\r\n\t() => {} // function () {}\r\n\r\n## 6. Set\r\n类似于数组，但元素不能重复，有如下成员函数\r\n\r\n\tadd(value);\r\n\tdelete(value);\r\n\thas(value);\r\n\tclear();\r\n\tkeys();\r\n\tvalues();\r\n\tentries();\r\n\tforEach(func);\r\n\t\r\n## 7. Map\r\n类似与对象，但键可以为任何值，成员函数与Set一致\r\n\r\n## 8. 原生Promise对象\r\n\r\n\tvar promise = new Promise(function (resolve, reject) {\r\n\t\tif (...) {\r\n\t\t\tresolve(value);\r\n\t\t} else {\r\n\t\t\treject(error);\r\n\t\t}\r\n\t});\r\n\tpromise.then(function (value) {}, function (error) {})\r\n\r\n## 9. generator函数\r\n使用function*声明，函数内部使用yield标注状态，外部使用next()，yield可用于同步操作、控制流\r\n\r\n\t// callback\r\n\tstep1(function (value1) {\r\n\t\tstep2(function (value2) { \r\n    \t    \t\r\n\t\t})\r\n\t});\r\n \r\n\t//Promise\r\n\tstep1()\r\n\t.then(step2)\r\n\t.catch()\r\n\t.done()\r\n \r\n\t// generator\r\n\tfunction* () {\r\n\t\tvar value1 = yield step1();\r\n\t\tvar value2 = yield step2();\r\n\t}\r\n\r\n## 10. Class getter setter\r\n\r\n\t// ES5\r\n\tfunction Point (x, y) {\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t}\r\n\tPoint.prototype.toString = function () {\r\n\t\treturn \"(\" + this.x + \",\" + this.y + \")\";\r\n\t}\r\n\t// ES6\r\n\tClass Point {\r\n\t\tconstructor(x, y) {\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t}\r\n\t\ttoString () {\r\n\t\t\treturn \"(\" + this.x + \",\" + this.y + \")\";\r\n\t\t} \r\n\t\tset x(x) {this.x = x;}\r\n\t\tget x() {return this.x;}\r\n\t\tset y(y) {this.y = y;}\r\n\t\tget y() {}\r\n\t}","__v":0,"createTime":"2015-10-17 17:02:48"},{"_id":"5707ce034843cf0759639f31","title":"Node Addon开发指南","content":"#一. 技术支持\r\nNode实现跨平台和语言扩展的核心技术有：\r\n\r\n在0.8版本中，node决定采用一种跨平台效果明显的项目生成器 - GYP(generate your project)，可以帮助开发者生成各个平台下的项目文件，node源码就是用GYP编译的。\r\n\r\nV8引擎是Node的动力来源之一。它自身由C++写成，可以实现JavaScript与C++的互相调用。\r\n\r\nlibuv库是Node的动力来源之二。Node能够实现跨平台的一个诀窍就是它的libuv库，这个库是跨平台的一层封装，通过它去调用一些底层操作，比自己在各个平台下编写实现要高效得多。libuv封装的功能包括事件循环、文件操作等。\r\n\r\nnode-gyp和node-ffi是两个可以实现node调用C代码的模块，实例如下：\r\n\r\n以下所有代码的运行环境为\r\n\r\nsystem: OS X\r\n\r\nnode version: V0.12.2\r\n\r\nnpm version: V2.12.1\r\n\r\n# 二. GYP\r\n## 2.1. 依赖包：\r\nnode-gyp：<https://www.npmjs.com/package/node-gyp>（全局安装）\r\n\r\nnan：<https://www.npmjs.com/package/nan>\r\n\r\nbindings：<https://www.npmjs.com/package/bindings> （可选）\r\n\r\n## 2.2. 步骤：\r\n### 2.2.1. 创建binding.gyp文件\r\n\r\n\t{\r\n\t\t\"targets\": [\r\n\t\t\t{\r\n\t\t\t\t\"target_name\": \"arithmetic\",\r\n\t\t\t\t\"sources\": [ \"lib.c\", \"arithmetic.cc\" ]\r\n\t\t\t}\r\n\t\t]\r\n\t}\r\n\t\r\n详细字段请见https://chromium.googlesource.com/external/gyp/+/master/docs/UserDocumentation.md\r\n\r\n### 2.2.2. 创建lib.h头文件和lib.c实现文件\r\n\r\n\t// lib.h 运算库头文件\r\n\t#ifndef ARITHMETIC_H\r\n\t#define ARITHMETIC_H\r\n\textern int add(int a, int b);\r\n\textern int subtract(int a, int b);\r\n\textern int multiply(int a, int b);\r\n\textern int divide(int a, int b);\r\n\textern int factorial(int max);\r\n\t#endif\r\n \r\n\t// lib.c 运算库的C代码实现\r\n\t#include \"lib.h\"\r\n\tint add(int a, int b) {\r\n\t\treturn a + b;\r\n\t}\r\n\tint subtract(int a, int b) {\r\n\t\treturn a - b;\r\n\t}\r\n\tint multiply(int a, int b) {\r\n\t\treturn a * b;\r\n\t}\r\n\tint divide(int a, int b) {\r\n\t\treturn a / b;\r\n\t}\r\n\tint factorial(int max) {\r\n\t\tint i = max;\r\n\t\tint result = 1;\r\n\t\twhile (i >= 2) {\r\n\t\t\tresult *= i--;\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\t\r\n### 2.2.3. 创建arichmetic.cc文件引入头文件并创建node模块\r\n\r\n\t#include <node.h>\r\n\t#include <v8.h>\r\n\tusing namespace v8;\r\n\t// 引入运算库头文件\r\n\textern \"C\" {\r\n\t\t#include \"lib.h\"\r\n\t}\r\n\t// 声明参数检查函数\r\n\textern bool checkArgs(const v8::FunctionCallbackInfo<Value>& args, int maxLength);\r\n\t// 封装C函数为node可识别的函数\r\n\tvoid Node_Add(const v8::FunctionCallbackInfo<Value>& args) {\r\n\t\tIsolate* isolate = Isolate::GetCurrent();\r\n\t\tHandleScope scope(isolate);\r\n\t\tif (checkArgs(args, 2)) {\r\n\t\t\tint value = add(args[0]->NumberValue(), args[1]->NumberValue());\r\n\t\t\targs.GetReturnValue().Set(Number::New(isolate, value));\r\n\t\t}\r\n\t}\r\n\tvoid Node_Subtract(const v8::FunctionCallbackInfo<Value>& args) {\r\n\t\tIsolate* isolate = Isolate::GetCurrent();\r\n\t\tHandleScope scope(isolate);\r\n\t\tif (checkArgs(args, 2)) {\r\n\t\t\tint value = subtract(args[0]->NumberValue(), args[1]->NumberValue());\r\n\t\t\targs.GetReturnValue().Set(Number::New(isolate, value));\r\n\t\t}\r\n\t}\r\n\tvoid Node_Multiply(const v8::FunctionCallbackInfo<Value>& args) {\r\n\t\tIsolate* isolate = Isolate::GetCurrent();\r\n\t\tHandleScope scope(isolate);\r\n\t\tif (checkArgs(args, 2)) {\r\n\t\t\tint value = multiply(args[0]->NumberValue(), args[1]->NumberValue());\r\n\t\t\targs.GetReturnValue().Set(Number::New(isolate, value));\r\n\t\t}\r\n\t}\r\n\tvoid Node_Divide(const v8::FunctionCallbackInfo<Value>& args) {\r\n\t\tIsolate* isolate = Isolate::GetCurrent();\r\n\t\tHandleScope scope(isolate);\r\n\t\tif (checkArgs(args, 2)) {\r\n\t\t\tint value = divide(args[0]->NumberValue(), args[1]->NumberValue());\r\n\t\t\targs.GetReturnValue().Set(Number::New(isolate, value));\r\n\t\t}\r\n\t}\r\n\tvoid Node_Factorial(const v8::FunctionCallbackInfo<Value>& args) {\r\n\t\tIsolate* isolate = Isolate::GetCurrent();\r\n\t\tHandleScope scope(isolate);\r\n\t\tif (checkArgs(args, 1)) {\r\n\t\t\tint value = factorial(args[0]->NumberValue());\r\n\t\t\targs.GetReturnValue().Set(Number::New(isolate, value));\r\n\t\t}\r\n\t}\r\n\t// 检查参数长度和数据类型\r\n\tbool checkArgs(const v8::FunctionCallbackInfo<Value>& args, int maxLength) {\r\n\t\tIsolate* isolate = Isolate::GetCurrent();\r\n\t\tif (args.Length() < maxLength) {\r\n\t\t\tisolate->ThrowException(Exception::TypeError(\r\n\t\t\tString::NewFromUtf8(isolate, \"Wrong number of arguments\")));\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tfor (int i = 0; i < maxLength; i++) {\r\n\t\t\tif (!args[i]->IsNumber()) {\r\n\t\t\t\tisolate->ThrowException(Exception::TypeError(\r\n\t\t\t\tString::NewFromUtf8(isolate, \"Wrong arguments\")));\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\t// 定义node模块\r\n\tvoid Init(Handle<Object> exports, Handle<Object> module) {\r\n\t\tNODE_SET_METHOD(exports, \"add\", Node_Add);\r\n\t\tNODE_SET_METHOD(exports, \"subtract\", Node_Subtract);\r\n\t\tNODE_SET_METHOD(exports, \"multiply\", Node_Multiply);\r\n\t\tNODE_SET_METHOD(exports, \"divide\", Node_Divide);\r\n\t\tNODE_SET_METHOD(exports, \"factorial\", Node_Factorial);\r\n\t}\r\n\tNODE_MODULE(arithmetic, Init)\r\n\t\r\n### 2.2.4. 创建arithmetic.js文件调用该模块\r\n\r\n\t// 没有安装bindings的加载方式\r\n\t// var addon = require(\"./build/Release/arithmetic.node\");\r\n\t// bindings的加载方式\r\n\tvar addon = require(\"bindings\")(\"arithmetic\");\r\n\tconsole.log(\"the result of 5 add 5 is: \" + addon.add(5, 5));\r\n\tconsole.log(\"the result of 5 subtract 5 is: \" + addon.subtract(5, 5));\r\n\tconsole.log(\"the result of 5 multiply 5 is: \" + addon.multiply(5, 5));\r\n\tconsole.log(\"the result of 5 divide 5 is: \" + addon.divide(5, 5));\r\n\tconsole.log(\"the result of factorial 5 is: \" + addon.factorial(5));\r\n\t\r\n### 2.2.5. 执行命令\r\n\r\n\tnode-gyp configure\r\n\tnode-gyp build\r\n\tnode arithmetic.js\r\n\t// 如找不到node-gyp命令，可全局安装node-gyp，或使用node_modules/node-gyp/bin/node-gyp.js代替\r\n\t// 可用node-gyp rebuild代替configure和build\r\n\t// output :\r\n\t// the result of 5 add 5 is: 10\r\n\t// the result of 5 subtract 5 is: 0\r\n\t// the result of 5 multiply 5 is: 25\r\n\t// the result of 5 divide 5 is: 1\r\n\t// the result of factorial 5 is: 120\r\n## 2.3. 目录结构：\r\n\r\n\t-build（gyp生成目录，勿手动添加）\r\n\t\t-Release\r\n\t\t\t-...\r\n\t\t\tarithmetic.node（生成的node模块，二进制）\r\n\t\t...\r\n\tarithmetic.cc（C++文件）\r\n\tarithmetic.js（node执行js文件）\r\n\tbinding.gyp （gyp配置文件）\r\n\tlib.h（C头文件）\r\n\tlib.c（C实现文件）\r\n\tpackage.json（npm配置文件）\r\n\trun.sh（执行脚本）\r\n\t\r\n## 2.4. 备注：\r\n1.如找不到node-gyp命令，可npm install -g node-gyp，或使用node_modules/node-gyp/bin/node-gyp.js代替\r\n\r\n2.C代码实现的库文件不能与C++文件同名，否则会加载异常\r\n\r\n# 三. node-ffi\r\n## 3.1. 依赖包：\r\nnode-ffi: <https://www.npmjs.com/package/node-ffi>\r\n\r\n## 3.2. 步骤：\r\n### 3.2.1. 创建arithmetic.c库文件\r\n\r\n\t#if defined(WIN32) || defined(_WIN32)\r\n\t#define EXPORT __declspec(dllexport)\r\n\t#else\r\n\t#define EXPORT\r\n\t#endif\r\n\tEXPORT int add(int a, int b) {\r\n\t\treturn a + b;\r\n\t}\r\n\tEXPORT int subtract(int a, int b) {\r\n\t\treturn a - b;\r\n\t}\r\n\tEXPORT int multiply(int a, int b) {\r\n\t\treturn a * b;\r\n\t}\r\n\tEXPORT int divide(int a, int b) {\r\n\t\treturn a / b;\r\n\t}\r\n\tEXPORT int factorial(int max) {\r\n\t\tint i = max;\r\n\t\tint result = 1;\r\n\t\twhile (i >= 2) {\r\n\t\t\tresult *= i--;\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\t\r\n### 3.2.2. 创建arithmetic.js调用ffi模块加载库\r\n\r\n\tvar ffi = require(\"ffi\");\r\n\tvar lib = ffi.Library(\"./arithmetic\", {\r\n\t\t\"add\": [\"int\", [\"int\", \"int\"]],\r\n\t\t\"subtract\": [\"int\", [\"int\", \"int\"]],\r\n\t\t\"multiply\": [\"int\", [\"int\", \"int\"]],\r\n\t\t\"divide\": [\"int\", [\"int\", \"int\"]],\r\n\t\t\"factorial\": [\"int\", [\"int\"]]\r\n\t});\r\n\tconsole.log(\"the result of 5 add 5 is: \" + lib.add(5, 5));\r\n\tconsole.log(\"the result of 5 subtract 5 is: \" + lib.subtract(5, 5));\r\n\tconsole.log(\"the result of 5 multiply 5 is: \" + lib.multiply(5, 5));\r\n\tconsole.log(\"the result of 5 divide 5 is: \" + lib.divide(5, 5));\r\n\tconsole.log(\"the result of factorial 5 is: \" + lib.factorial(5));\r\n\t\r\n### 3.2.3. 执行命令\r\n\r\n\tgcc -dynamiclib -undefined suppress -flat_namespace arithmetic.c -o arithmetic.dylib\r\n\tnode arithmetic.js\r\n\t// output :\r\n\t// the result of 5 add 5 is: 10\r\n\t// the result of 5 subtract 5 is: 0\r\n\t// the result of 5 multiply 5 is: 25\r\n\t// the result of 5 divide 5 is: 1\r\n\t// the result of factorial 5 is: 120\r\n\t\r\n## 3.3. 目录结构：\r\n\tarithmetic.c（C文件）\r\n\tarithmetic.dylib（二进制动态库）\r\n\tarithmetic.js（node执行js文件）\r\n\tpackage.json（npm配置文件）\r\n\trun.sh（执行脚本）\r\n\r\n# 四. 其他\r\n\r\nnode-ffi（foreign function interface）适用于简单的函数调用，使用相对方便\r\n\r\nnode-gyp（generate your project）功能更加完善，适用于复杂的应用场景\r\n\r\nPS：以上所有代码的运行环境为\r\n\r\nsystem: OS X\r\n\r\nnode version: V0.12.2\r\n\r\nnpm version: V2.12.1\r\n\r\nlinux和windows以及node版本较低的情况请参考\r\n\r\n<https://github.com/nodejs/node-addon-examples>\r\n\r\n<https://github.com/node-ffi/node-ffi/tree/master/example/factorial>","__v":0,"createTime":"2015-11-23 21:33:28"},{"_id":"5707ce034843cf0759639f32","title":"V8 C++开发总结","content":"# 一. Overview\r\nV8是由谷歌开发的开源高性能Javascript引擎，源码由C++编写而成，被谷歌用于chrome浏览器，也是node构建的Javascript引擎。\r\n\r\n官网：<https://developers.google.com/v8/?hl=zh-CN>\r\n\r\ngithub：<https://github.com/v8/v8>\r\n\r\n官网好像没有提供详细的document，详细API可以参见<http://izs.me/v8-docs/>\r\n\r\n# 二. Features\r\n## 2.1. Isolate\r\nIsolate可以看成V8引擎的一个实例，不同Isolate不能获取到其他isolate中的变量\r\n\r\nV8会创建一个默认的Isolate，可以通过Isolate::getCurrent()获取当前实例(默认)\r\n\r\n也可以通过Isolate::new()来创建实例，注意要使用HandleScope来进入Isolate，这时Isolate::getCurrent()将返回该isolate\r\n## 2.2. Context\r\nContext是V8引擎的上下文环境(类似于js的Global变量)，同样一个Isolate对应一个Context\r\n\r\n可以通过isolate->getCurrentContext()获取当前isolate的上下文环境，也可以通过Context::new()来创建\r\n## 2.3. Value\r\nV8封装了很多的基本类型，有最基本的Number、String、Boolean，也有复杂的Array、Object、RegExp，还有与node直接关联的Function、Script等等\r\n\r\n这些类型都继承自共同的父类Value\r\n\r\nValue类中封装了类型判断和转换的成员函数，例如IsNumber和ToNumber，满足对变量类型的需要\r\n# 三. Usage\r\nV8编写一个可以被node识别的二进制module，需要使用指定的函数和遵循一定的规范。\r\n\r\n在最新版本的V8代码中，编写一个node模块有如下几个步骤：\r\n\r\n1.首先需要引入node和v8的C++头文件，一般情况下这两个头文件在node安装路径中的include目录下，include下还有一些其他特定功能的头文件按需使用\r\n\r\n\t#include <node.h>\r\n\t#include <v8.h>\r\n\t\r\n2.然后编写函数代码\r\n\r\n\t// public function\r\n\tvoid Node_Add(const v8::FunctionCallbackInfo<Value>& args) {\r\n    \tIsolate* isolate = Isolate::GetCurrent();\r\n    \tHandleScope scope(isolate);\r\n    \tif (checkArgs(args, 2)) {\r\n        \tint value = add(args[0]->NumberValue(), args[1]->NumberValue());\r\n        \targs.GetReturnValue().Set(Number::New(isolate, value));\r\n    \t}\r\n\t}\r\n\t// private function\r\n\tint add(int a, int b) {\r\n  \t\treturn a + b;\r\n\t}\r\n\tbool checkArgs(const v8::FunctionCallbackInfo<Value>& args, int maxLength) {\r\n    \tIsolate* isolate = Isolate::GetCurrent();\r\n    \tif (args.Length() < maxLength) {\r\n      \t\tisolate->ThrowException(Exception::TypeError(\r\n            \tString::NewFromUtf8(isolate, \"Wrong number of arguments\")));\r\n        \treturn false;\r\n    \t}\r\n    \tfor (int i = 0; i < maxLength; i++) {\r\n        \tif (!args[i]->IsNumber()) {\r\n            \tisolate->ThrowException(Exception::TypeError(\r\n                \tString::NewFromUtf8(isolate, \"Wrong arguments\")));\r\n            \treturn false;\r\n        \t}\r\n    \t}\r\n    \treturn true;\r\n\t}\r\n\r\n这里Node_Add是要暴露给node的函数，这个函数需要有如下特性：\r\n\r\n参数类型必须为const v8::FunctionCallbackInfo<Value>&，该类型为V8封装的参数处理类型(类似于js的arguments)，node传递的参数通过数组取值的方式获取\r\n\r\n进入isolate以处理变量，通常做法是直接获取当前isolate使用\r\n\r\n一般为void函数无返回值，node只能读取通过args.GetReturnValue().Set(return)设置的返回值\r\n\r\n3.定义node模块\r\n\r\n\t// 定义node模块\r\n\tvoid Init(Handle<Object> exports, Handle<Object> module) {\r\n    \tNODE_SET_METHOD(exports, \"add\", Node_Add);\r\n\t}\r\n\tNODE_MODULE(arithmetic, Init)\r\n\r\nNODE_MODULE是V8内建函数，用于定义node模块\r\n\r\n第二个函数是定义函数，通常有两个参数exports和module(同于node定义模块)，如果不需要改变exports则不需要module参数\r\n\r\nNODE_SET_METHOD也是V8内建函数，用于给exports添加属性\r\n\r\n4.至此一个用V8定义的Node模块就完成了，接下来用node-gyp编译出二进制文件就可以给node使用\r\n\r\n最后写个node代码测试一下成果~\r\n\r\n\tvar addon = require(\"bindings\")(\"arithmetic\");\r\n\tconsole.log(\"the result of 5 add 5 is: \"\" + addon.add(5, 5));","__v":0,"createTime":"2015-12-05 16:37:18"}],"comments":[{"_id":"5707cf49951b4e085834d233","bid":"5707ce034843cf0759639f2e","name":"ww","phone":"","email":"","content":"踩踩踩","__v":0,"createTime":"2015-10-01 13:51:10"},{"_id":"5707cf55951b4e085834d234","bid":"5707ce034843cf0759639f2f","name":"ww","phone":"","email":"","content":"给你一个赞","__v":0,"createTime":"2015-10-01 01:52:41"},{"_id":"5707cf68951b4e085834d235","bid":"5707ce034843cf0759639f2f","name":"阿斯顿f","phone":"阿斯顿f","email":"阿斯顿f","content":"兄弟厉害啊","__v":0,"createTime":"2015-10-21 15:52:12"}],"abouts":[{"_id":"5707ce034843cf0759639f3a","title":"name:","content":"廖仲武","__v":0,"createTime":"2015-09-02 19:27:10"},{"_id":"5707ce034843cf0759639f3b","title":"education:","content":"NanJing University","__v":0,"createTime":"2015-09-02 19:27:10"},{"_id":"5707ce034843cf0759639f3c","title":"birthday:","content":"1995-03-01","__v":0,"createTime":"2015-09-02 19:27:10"},{"_id":"5707ce034843cf0759639f3e","title":"github:","content":"@liaozhongwu95","__v":0,"createTime":"2015-09-02 19:27:10"},{"_id":"5707ce034843cf0759639f3d","title":"work:","content":"FrontEnd engineer @meituan","__v":0,"createTime":"2015-09-02 19:27:10"},{"_id":"5707ce034843cf0759639f3f","title":"email:","content":"liaozhongwu95@163.com","__v":0,"createTime":"2015-09-02 19:27:10"},{"_id":"5707ce034843cf0759639f40","title":"weibo:","content":"@梦遥在何方","__v":0,"createTime":"2015-09-02 19:27:10"},{"_id":"5707ce034843cf0759639f41","title":"QQ:","content":"@840351238","__v":0,"createTime":"2015-09-02 19:27:10"},{"_id":"5707ce034843cf0759639f42","title":"facebook:","content":"@廖仲武","__v":0,"createTime":"2015-09-02 19:27:10"},{"_id":"5707ce034843cf0759639f43","title":"twitter:","content":"@liaozhongwu95","__v":0,"createTime":"2015-09-02 19:27:10"}],"notices":[{"_id":"5707ce034843cf0759639f33","title":"<a href=\"/about\">lzw</a> create the site","__v":0,"createTime":"2015-09-02 18:45:19"},{"_id":"5707ce034843cf0759639f34","title":"the chat system had moved to <a href=\"http://liaozhongwu.cn:8000\" target=\"_blank\">chat</a>","__v":0,"createTime":"2015-09-02 18:48:41"},{"_id":"5707ce034843cf0759639f35","title":"<a href=\"/about\">lzw</a> published a blog <a href=\"/blog/5707ce034843cf0759639f2e\">雪颂</a>","__v":0,"createTime":"2015-09-03 20:23:18"},{"_id":"5707ce034843cf0759639f36","title":"<a href=\"/about\">lzw</a> published a blog <a href=\"/blog/5707ce034843cf0759639f2f\">Promise的理解</a>","__v":0,"createTime":"2015-09-28 16:43:51"},{"_id":"5707ce034843cf0759639f37","title":"<a href=\"/about\">lzw</a> published a blog <a href=\"/blog/5707ce034843cf0759639f30\">ESMAScript6笔记</a>","__v":0,"createTime":"2015-10-17 17:02:48"},{"_id":"5707ce034843cf0759639f38","title":"<a href=\"/about\">lzw</a> published a blog <a href=\"/blog/5707ce034843cf0759639f31\">Node Addon开发指南</a>","__v":0,"createTime":"2015-11-23 21:33:28"},{"_id":"5707ce034843cf0759639f39","title":"<a href=\"/about\">lzw</a> published a blog <a href=\"/blog/5707ce034843cf0759639f32\">V8 C++开发总结</a>","__v":0,"createTime":"2015-12-05 16:37:18"}]}